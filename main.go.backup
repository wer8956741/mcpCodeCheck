package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/ThinkInAIXYZ/go-mcp/protocol"
	"github.com/ThinkInAIXYZ/go-mcp/server"
	"github.com/ThinkInAIXYZ/go-mcp/transport"
)

// PackageLintRequest 定义包级代码检查请求结构
type PackageLintRequest struct {
	Files            []string `json:"files" description:"需要检查的文件列表，请提供绝对路径。将检测这些文件所在的包，避免跨文件引用误报" required:"true"`
	CheckOnlyChanges bool     `json:"checkOnlyChanges" description:"是否只检查变更文件（默认true，相对于HEAD~1），设为false可检查全部代码" default:"true"`
	VendorMode       bool     `json:"vendorMode" description:"是否使用vendor模式管理依赖（默认true），true表示使用vendor模式，false表示使用go modules模式" default:"true"`
}

// ModuleLintRequest 定义模块级代码检查请求结构
type ModuleLintRequest struct {
	ProjectPath      string `json:"projectPath" description:"Go模块根目录路径（包含go.mod的目录），请提供绝对路径" required:"true"`
	CheckOnlyChanges bool   `json:"checkOnlyChanges" description:"是否只检查变更文件（默认true，相对于HEAD~1），设为false可检查全部代码" default:"true"`
	VendorMode       bool   `json:"vendorMode" description:"是否使用vendor模式管理依赖（默认true），true表示使用vendor模式，false表示使用go modules模式" default:"true"`
}

// ProjectLintRequest 定义项目级代码检查请求结构
type ProjectLintRequest struct {
	ProjectPath      string `json:"projectPath" description:"项目根目录路径，请提供绝对路径。将检测该目录下所有Go文件" required:"true"`
	CheckOnlyChanges bool   `json:"checkOnlyChanges" description:"是否只检查变更文件（默认true，相对于HEAD~1），设为false可检查全部代码" default:"true"`
	VendorMode       bool   `json:"vendorMode" description:"是否使用vendor模式管理依赖（默认true），true表示使用vendor模式，false表示使用go modules模式" default:"true"`
}

// GolangciLintOutput golangci-lint 的实际输出格式
type GolangciLintOutput struct {
	Issues []Issue `json:"Issues"`
	Report struct {
		Linters []struct {
			Name    string `json:"Name"`
			Enabled bool   `json:"Enabled"`
		} `json:"Linters"`
	} `json:"Report"`
}

// LintResult 表示代码检查结果
type LintResult struct {
	Issues []Issue `json:"Issues"`
}

// Issue 表示单个代码问题
type Issue struct {
	FromLinter           string       `json:"FromLinter"`
	Text                 string       `json:"Text"`
	Severity             string       `json:"Severity"`
	SourceLines          []string     `json:"SourceLines"`
	Replacement          *Replacement `json:"Replacement"`
	Pos                  Pos          `json:"Pos"`
	ExpectNoLint         bool         `json:"ExpectNoLint"`
	ExpectedNoLintLinter string       `json:"ExpectedNoLintLinter"`
}

type Replacement struct {
	NewLines []string `json:"NewLines"`
}

type Pos struct {
	Filename string `json:"Filename"`
	Offset   int    `json:"Offset"`
	Line     int    `json:"Line"`
	Column   int    `json:"Column"`
}

// findGoModRoot 从指定目录开始向上查找go.mod文件
func findGoModRoot(startDir string) (string, error) {
	dir := startDir
	for {
		goModPath := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(goModPath); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			break // 已经到达根目录
		}
		dir = parent
	}
	return "", fmt.Errorf("未找到go.mod文件")
}

// getProjectRootFromFile 从文件路径获取项目根目录
func getProjectRootFromFile(filePath string) (string, error) {
	if !filepath.IsAbs(filePath) {
		return "", fmt.Errorf("文件路径必须是绝对路径: %s", filePath)
	}

	// 从文件所在目录开始向上查找go.mod
	searchDir := filepath.Dir(filePath)
	log.Printf("从文件 %s 开始搜索项目根目录，搜索目录: %s", filePath, searchDir)

	if goModRoot, err := findGoModRoot(searchDir); err == nil {
		log.Printf("找到Go模块根目录: %s", goModRoot)
		return goModRoot, nil
	}

	// 如果没有找到go.mod，使用文件所在目录作为项目根目录
	log.Printf("未找到go.mod文件，使用文件所在目录作为项目根目录: %s", searchDir)
	return searchDir, nil
}

// getPackagesFromFiles 从文件列表中获取包路径列表（去重）
func getPackagesFromFiles(files []string) (map[string][]string, error) {
	// 返回 map[projectRoot][]packagePaths 的结构
	projectPackages := make(map[string]map[string]bool)
	result := make(map[string][]string)

	for _, file := range files {
		if file == "" {
			continue
		}

		if !filepath.IsAbs(file) {
			return nil, fmt.Errorf("文件路径必须是绝对路径: %s", file)
		}

		// 检查文件是否存在且是.go文件
		if _, err := os.Stat(file); err != nil {
			log.Printf("警告：文件 %s 不存在，跳过", file)
			continue
		}

		if !strings.HasSuffix(file, ".go") {
			log.Printf("警告：文件 %s 不是Go文件，跳过", file)
			continue
		}

		// 获取项目根目录
		projectRoot, err := getProjectRootFromFile(file)
		if err != nil {
			return nil, fmt.Errorf("获取项目根目录失败: %v", err)
		}

		// 获取文件所在目录作为包路径
		packageDir := filepath.Dir(file)

		// 转换为相对于项目根目录的包路径
		relPackagePath, err := filepath.Rel(projectRoot, packageDir)
		if err != nil {
			log.Printf("警告：无法计算包路径 %s 相对于项目根目录 %s 的路径：%v", packageDir, projectRoot, err)
			continue
		}

		// 在项目根目录的情况下使用 "."
		if relPackagePath == "" || relPackagePath == "." {
			relPackagePath = "."
		} else {
			// 确保使用正斜杠（Go模块路径格式）
			relPackagePath = strings.ReplaceAll(relPackagePath, "\\", "/")
			// 如果路径不以./开头，添加它
			if !strings.HasPrefix(relPackagePath, "./") {
				relPackagePath = "./" + relPackagePath
			}
		}

		// 按项目根目录分组包路径
		if projectPackages[projectRoot] == nil {
			projectPackages[projectRoot] = make(map[string]bool)
		}

		if !projectPackages[projectRoot][relPackagePath] {
			projectPackages[projectRoot][relPackagePath] = true
			log.Printf("发现包: %s (项目: %s, 文件: %s)", relPackagePath, projectRoot, file)
		}
	}

	// 转换为最终结果格式
	for projectRoot, packages := range projectPackages {
		var packageList []string
		for pkg := range packages {
			packageList = append(packageList, pkg)
		}
		result[projectRoot] = packageList
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("没有找到有效的Go包")
	}

	return result, nil
}

// checkGolangciLintInstalled 检查golangci-lint是否已安装
func checkGolangciLintInstalled() error {
	_, err := exec.LookPath("golangci-lint")
	if err != nil {
		return fmt.Errorf("golangci-lint 未安装或不在PATH中")
	}
	return nil
}

// getChangedGoFiles 获取相对于指定 commit 的变更 Go 文件列表
func getChangedGoFiles(projectRoot string, fromRev string) ([]string, error) {
	log.Printf("获取项目 %s 中相对于 %s 的变更 Go 文件", projectRoot, fromRev)

	// 执行 git diff 命令获取变更文件
	cmd := exec.Command("git", "diff", "--name-only", fromRev, "HEAD")
	cmd.Dir = projectRoot

	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("执行 git diff 失败: %v", err)
	}

	var changedGoFiles []string
	lines := strings.Split(strings.TrimSpace(string(output)), "\n")

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		// 只处理 .go 文件
		if strings.HasSuffix(line, ".go") {
			// 转换为绝对路径
			absPath := filepath.Join(projectRoot, line)

			// 检查文件是否存在（可能已被删除）
			if _, err := os.Stat(absPath); err == nil {
				changedGoFiles = append(changedGoFiles, absPath)
				log.Printf("发现变更的 Go 文件: %s", absPath)
			} else {
				log.Printf("变更文件已被删除，跳过: %s", absPath)
			}
		}
	}

	if len(changedGoFiles) == 0 {
		log.Printf("未找到变更的 Go 文件")
		return nil, fmt.Errorf("相对于 %s 未找到变更的 Go 文件", fromRev)
	}

	log.Printf("总共找到 %d 个变更的 Go 文件", len(changedGoFiles))
	return changedGoFiles, nil
}

// runGolangciLint 执行 golangci-lint 检查
func runGolangciLint(projectRoot string, targets []string, targetType string, checkOnlyChanges bool, vendorMode bool) (*LintResult, error) {
	log.Printf("开始代码检查，项目根目录: %s，检测目标: %v，类型: %s，vendor模式: %v", projectRoot, targets, targetType, vendorMode)

	// 检查golangci-lint是否已安装
	if err := checkGolangciLintInstalled(); err != nil {
		log.Printf("golangci-lint 检查失败: %v", err)
		return &LintResult{
			Issues: []Issue{
				{
					FromLinter: "lint-mcp",
					Text: `golangci-lint 未安装。请先安装 golangci-lint v1.52.2：

方法1 - 使用 Go install：
go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.52.2

方法2 - 使用包管理器：
# macOS (Homebrew)
brew install golangci-lint
brew pin golangci-lint && brew install golangci-lint@1.52.2

方法3 - 使用安装脚本：
curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.52.2

安装完成后请确保 golangci-lint 在 PATH 环境变量中。`,
					Pos: Pos{
						Filename: "system",
						Line:     0,
						Column:   0,
					},
				},
			},
		}, nil
	}

	// 检查是否是Go项目
	goModPath := filepath.Join(projectRoot, "go.mod")
	if _, err := os.Stat(goModPath); err == nil {
		if vendorMode {
			log.Printf("检测到Go项目，使用vendor模式进行检查")
		} else {
			log.Printf("检测到Go项目，使用标准模式进行检查")
		}
	} else {
		log.Printf("未检测到go.mod文件，将尝试对Go文件进行检查")
	}

	// 构建命令参数
	args := []string{"run"}

	// 如果是vendor模式，添加对应的参数（需要在其他参数之前）
	if vendorMode {
		args = append(args, "--modules-download-mode=vendor")
		log.Printf("启用vendor模式，使用 --modules-download-mode=vendor 参数")
	}

	// 添加输出格式参数
	args = append(args, "--out-format", "json", "--print-issued-lines=false", "--print-linter-name=true")

	// 如果只检查变更，添加 --new-from-rev 参数
	if checkOnlyChanges {
		args = append(args, "--new-from-rev", "HEAD~1")
		log.Printf("启用变更检测模式，只检查相对于 HEAD~1 的变更")
	} else {
		log.Printf("全量检查模式，检查所有代码")
	}

	// 添加检测目标
	args = append(args, targets...)

	log.Printf("执行命令: golangci-lint %v", args)
	log.Printf("命令执行目录: %s", projectRoot)

	// 创建命令
	cmd := exec.Command("golangci-lint", args...)
	cmd.Dir = projectRoot // 设置工作目录为项目根目录

	// 设置环境变量
	cmd.Env = os.Environ()

	// 执行命令
	output, cmdErr := cmd.CombinedOutput()

	log.Printf("命令输出长度: %d", len(output))
	log.Printf("命令执行错误: %v", cmdErr)

	// 处理命令执行错误
	if cmdErr != nil {
		// 检查是否是"command not found"错误（备用检查）
		if strings.Contains(cmdErr.Error(), "executable file not found") ||
			strings.Contains(cmdErr.Error(), "command not found") {
			return &LintResult{
				Issues: []Issue{
					{
						FromLinter: "lint-mcp",
						Text:       "golangci-lint 命令未找到。请确保已正确安装 golangci-lint 并且在 PATH 环境变量中。",
						Pos: Pos{
							Filename: "system",
							Line:     0,
							Column:   0,
						},
					},
				},
			}, nil
		}

		// 其他执行错误，但仍尝试解析输出（golangci-lint可能因为检测到问题而返回非零退出码）
		log.Printf("golangci-lint 执行返回非零退出码，但这可能是正常的（检测到代码问题）")
	}

	// golangci-lint 当发现问题时会返回非零退出码，但输出仍然有效
	if len(output) == 0 {
		if cmdErr != nil {
			// 如果没有输出且有错误，返回错误信息
			return &LintResult{
				Issues: []Issue{
					{
						FromLinter: "golangci-lint",
						Text:       fmt.Sprintf("golangci-lint 执行失败: %v", cmdErr),
						Pos: Pos{
							Filename: "unknown",
							Line:     0,
							Column:   0,
						},
					},
				},
			}, nil
		}
		log.Printf("golangci-lint 没有输出，代码检查通过")
		return &LintResult{Issues: []Issue{}}, nil
	}

	// 从输出中提取JSON部分（去除日志信息）
	jsonOutput := extractJSONFromOutput(string(output))
	if jsonOutput == "" {
		log.Printf("未找到有效的JSON输出")
		maxLen := 200
		if len(output) < maxLen {
			maxLen = len(output)
		}
		return &LintResult{
			Issues: []Issue{
				{
					FromLinter: "golangci-lint",
					Text:       fmt.Sprintf("无法从golangci-lint输出中提取JSON格式数据\n原始输出前200字符: %s", string(output[:maxLen])),
					Pos: Pos{
						Filename: "unknown",
						Line:     0,
						Column:   0,
					},
				},
			},
		}, nil
	}

	log.Printf("提取的JSON输出: %s", jsonOutput)

	// 尝试解析输出
	var golangciOutput GolangciLintOutput
	if err := json.Unmarshal([]byte(jsonOutput), &golangciOutput); err != nil {
		log.Printf("JSON 解析失败: %v", err)
		maxLen := 50
		if len(jsonOutput) < maxLen {
			maxLen = len(jsonOutput)
		}
		log.Printf("提取的JSON前50字符: %s", jsonOutput[:maxLen])

		return &LintResult{
			Issues: []Issue{
				{
					FromLinter: "golangci-lint",
					Text:       fmt.Sprintf("JSON解析失败: %v\n请检查golangci-lint输出格式", err),
					Pos: Pos{
						Filename: "unknown",
						Line:     0,
						Column:   0,
					},
				},
			},
		}, nil
	}

	log.Printf("解析到 %d 个问题", len(golangciOutput.Issues))

	return &LintResult{Issues: golangciOutput.Issues}, nil
}

// extractJSONFromOutput 从golangci-lint输出中提取JSON部分
func extractJSONFromOutput(output string) string {
	log.Printf("原始输出内容: %s", output)

	// 如果输出为空，直接返回
	trimmedOutput := strings.TrimSpace(output)
	if trimmedOutput == "" {
		log.Printf("输出为空")
		return ""
	}

	// 如果输出以 { 开始且以 } 结束，可能是完整的JSON
	if strings.HasPrefix(trimmedOutput, "{") && strings.HasSuffix(trimmedOutput, "}") {
		log.Printf("输出似乎已经是完整的JSON")
		// 验证是否为有效的JSON
		var js map[string]interface{}
		if err := json.Unmarshal([]byte(trimmedOutput), &js); err == nil {
			return trimmedOutput
		}
		log.Printf("看似JSON但解析失败，继续尝试提取")
	}

	// 尝试提取JSON部分
	log.Printf("尝试从输出中提取JSON部分")

	// 分行处理，查找可能的JSON行
	lines := strings.Split(output, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "{") && strings.HasSuffix(line, "}") {
			// 验证是否为有效的JSON
			var js map[string]interface{}
			if err := json.Unmarshal([]byte(line), &js); err == nil {
				log.Printf("找到有效的JSON行")
				return line
			}
		}
	}

	// 如果没有找到完整的JSON行，尝试提取最长的JSON片段
	maxLength := 0
	bestJSON := ""

	for i, char := range output {
		if char == '{' {
			// 找到一个开始位置
			currentStart := i
			braceCount := 1

			// 向后查找匹配的结束括号
			for j := i + 1; j < len(output); j++ {
				if output[j] == '{' {
					braceCount++
				} else if output[j] == '}' {
					braceCount--
					if braceCount == 0 {
						// 找到一个完整的JSON片段
						length := j - currentStart + 1
						if length > maxLength {
							// 验证是否为有效的JSON
							candidate := output[currentStart : j+1]
							var js map[string]interface{}
							if err := json.Unmarshal([]byte(candidate), &js); err == nil {
								maxLength = length
								bestJSON = candidate
							}
						}
						break
					}
				}
			}
		}
	}

	if bestJSON != "" {
		log.Printf("找到最长的有效JSON片段，长度: %d", len(bestJSON))
		return bestJSON
	}

	// 如果仍然没有找到有效的JSON，返回空字符串
	log.Printf("未找到有效的JSON")
	return ""
}

// handlePackageLintRequest 处理包级代码检查请求
func handlePackageLintRequest(ctx context.Context, req *protocol.CallToolRequest) (*protocol.CallToolResult, error) {
	log.Printf("收到包级代码检查请求: %s", string(req.RawArguments))

	var lintReq PackageLintRequest
	if err := protocol.VerifyAndUnmarshal(req.RawArguments, &lintReq); err != nil {
		return nil, fmt.Errorf("无效的请求参数: %v", err)
	}

	log.Printf("解析后的请求: %+v", lintReq)

	// 设置默认值：如果没有明确指定，则设置默认值
	if req.RawArguments == nil {
		lintReq.CheckOnlyChanges = true
		lintReq.VendorMode = true
	} else {
		// 检查原始参数中是否包含字段，设置默认值
		var rawCheck map[string]interface{}
		if err := json.Unmarshal(req.RawArguments, &rawCheck); err == nil {
			if _, exists := rawCheck["checkOnlyChanges"]; !exists {
				lintReq.CheckOnlyChanges = true
			}
			if _, exists := rawCheck["vendorMode"]; !exists {
				lintReq.VendorMode = true
			}
		}
	}

	// 如果 checkOnlyChanges=true，忽略用户提供的文件参数，直接检查 git 最新变更的所有 Go 文件
	if lintReq.CheckOnlyChanges {
		log.Printf("checkOnlyChanges=true，通过 git 获取最新变更的 Go 文件进行检查")

		// 从用户提供的文件中选择一个来确定项目根目录，如果没有文件则返回错误
		if len(lintReq.Files) == 0 {
			return &protocol.CallToolResult{
				Content: []protocol.Content{
					&protocol.TextContent{
						Type: "text",
						Text: "checkOnlyChanges=true 时需要至少提供一个文件路径以确定项目根目录",
					},
				},
			}, nil
		}

		// 获取项目根目录（使用第一个文件）
		projectRoot, err := getProjectRootFromFile(lintReq.Files[0])
		if err != nil {
			return &protocol.CallToolResult{
				Content: []protocol.Content{
					&protocol.TextContent{
						Type: "text",
						Text: fmt.Sprintf("获取项目根目录失败: %v", err),
					},
				},
			}, nil
		}

		// 获取最新变更的 Go 文件
		changedFiles, err := getChangedGoFiles(projectRoot, "HEAD~1")
		if err != nil {
			return &protocol.CallToolResult{
				Content: []protocol.Content{
					&protocol.TextContent{
						Type: "text",
						Text: fmt.Sprintf("获取最新变更文件失败: %v", err),
					},
				},
			}, nil
		}

		log.Printf("检查项目 %s 中最新变更的 %d 个 Go 文件", projectRoot, len(changedFiles))

		// 执行检查，使用变更文件（不使用 --new-from-rev 参数）
		result, err := runGolangciLint(projectRoot, changedFiles, "package", false, lintReq.VendorMode)
		if err != nil {
			return nil, err
		}

		// 返回结果
		resultJSON, _ := json.Marshal(result)
		return &protocol.CallToolResult{
			Content: []protocol.Content{
				&protocol.TextContent{
					Type: "text",
					Text: string(resultJSON),
				},
			},
		}, nil
	}

	// checkOnlyChanges=false 时，使用包路径进行全面检查
	log.Printf("checkOnlyChanges=false，使用包路径进行全面检查")

	// 获取包路径列表（按项目分组）
	projectPackages, err := getPackagesFromFiles(lintReq.Files)
	if err != nil {
		return &protocol.CallToolResult{
			Content: []protocol.Content{
				&protocol.TextContent{
					Type: "text",
					Text: fmt.Sprintf("获取包路径失败: %v", err),
				},
			},
		}, nil
	}

	// 合并所有项目的检查结果
	var allIssues []Issue

	for projectRoot, packages := range projectPackages {
		log.Printf("检查项目 %s 的包: %v", projectRoot, packages)

		// 执行检查
		result, err := runGolangciLint(projectRoot, packages, "package", lintReq.CheckOnlyChanges, lintReq.VendorMode)
		if err != nil {
			return nil, err
		}

		// 合并结果
		allIssues = append(allIssues, result.Issues...)
	}

	// 返回合并后的结果
	finalResult := &LintResult{Issues: allIssues}
	resultJSON, _ := json.Marshal(finalResult)
	return &protocol.CallToolResult{
		Content: []protocol.Content{
			&protocol.TextContent{
				Type: "text",
				Text: string(resultJSON),
			},
		},
	}, nil
}

// handleModuleLintRequest 处理模块级代码检查请求
func handleModuleLintRequest(ctx context.Context, req *protocol.CallToolRequest) (*protocol.CallToolResult, error) {
	log.Printf("收到模块级代码检查请求: %s", string(req.RawArguments))

	var lintReq ModuleLintRequest
	if err := protocol.VerifyAndUnmarshal(req.RawArguments, &lintReq); err != nil {
		return nil, fmt.Errorf("无效的请求参数: %v", err)
	}

	log.Printf("解析后的请求: %+v", lintReq)

	// 设置默认值：如果没有明确指定，则设置默认值
	if req.RawArguments == nil {
		lintReq.CheckOnlyChanges = true
		lintReq.VendorMode = true
	} else {
		// 检查原始参数中是否包含字段，设置默认值
		var rawCheck map[string]interface{}
		if err := json.Unmarshal(req.RawArguments, &rawCheck); err == nil {
			if _, exists := rawCheck["checkOnlyChanges"]; !exists {
				lintReq.CheckOnlyChanges = true
			}
			if _, exists := rawCheck["vendorMode"]; !exists {
				lintReq.VendorMode = true
			}
		}
	}

	// 验证项目路径
	if !filepath.IsAbs(lintReq.ProjectPath) {
		return &protocol.CallToolResult{
			Content: []protocol.Content{
				&protocol.TextContent{
					Type: "text",
					Text: "项目路径必须是绝对路径",
				},
			},
		}, nil
	}

	// 检查go.mod是否存在
	goModPath := filepath.Join(lintReq.ProjectPath, "go.mod")
	if _, err := os.Stat(goModPath); err != nil {
		return &protocol.CallToolResult{
			Content: []protocol.Content{
				&protocol.TextContent{
					Type: "text",
					Text: fmt.Sprintf("指定路径不是Go模块根目录（未找到go.mod文件）: %s", lintReq.ProjectPath),
				},
			},
		}, nil
	}

	// 如果 checkOnlyChanges=true，忽略模块范围，直接检查 git 最新变更的所有 Go 文件
	if lintReq.CheckOnlyChanges {
		log.Printf("checkOnlyChanges=true，通过 git 获取最新变更的 Go 文件进行检查")

		// 获取最新变更的 Go 文件
		changedFiles, err := getChangedGoFiles(lintReq.ProjectPath, "HEAD~1")
		if err != nil {
			return &protocol.CallToolResult{
				Content: []protocol.Content{
					&protocol.TextContent{
						Type: "text",
						Text: fmt.Sprintf("获取最新变更文件失败: %v", err),
					},
				},
			}, nil
		}

		log.Printf("检查项目 %s 中最新变更的 %d 个 Go 文件", lintReq.ProjectPath, len(changedFiles))

		// 执行检查，使用变更文件（不使用 --new-from-rev 参数）
		result, err := runGolangciLint(lintReq.ProjectPath, changedFiles, "module", false, lintReq.VendorMode)
		if err != nil {
			return nil, err
		}

		// 返回结果
		resultJSON, _ := json.Marshal(result)
		return &protocol.CallToolResult{
			Content: []protocol.Content{
				&protocol.TextContent{
					Type: "text",
					Text: string(resultJSON),
				},
			},
		}, nil
	}

	// checkOnlyChanges=false 时，执行检查（检查整个模块）
	result, err := runGolangciLint(lintReq.ProjectPath, []string{"./..."}, "module", lintReq.CheckOnlyChanges, lintReq.VendorMode)
	if err != nil {
		return nil, err
	}

	// 返回结果
	resultJSON, _ := json.Marshal(result)
	return &protocol.CallToolResult{
		Content: []protocol.Content{
			&protocol.TextContent{
				Type: "text",
				Text: string(resultJSON),
			},
		},
	}, nil
}

// handleProjectLintRequest 处理项目级代码检查请求
func handleProjectLintRequest(ctx context.Context, req *protocol.CallToolRequest) (*protocol.CallToolResult, error) {
	log.Printf("收到项目级代码检查请求: %s", string(req.RawArguments))

	var lintReq ProjectLintRequest
	if err := protocol.VerifyAndUnmarshal(req.RawArguments, &lintReq); err != nil {
		return nil, fmt.Errorf("无效的请求参数: %v", err)
	}

	log.Printf("解析后的请求: %+v", lintReq)

	// 设置默认值：如果没有明确指定，则设置默认值
	if req.RawArguments == nil {
		lintReq.CheckOnlyChanges = true
		lintReq.VendorMode = true
	} else {
		// 检查原始参数中是否包含字段，设置默认值
		var rawCheck map[string]interface{}
		if err := json.Unmarshal(req.RawArguments, &rawCheck); err == nil {
			if _, exists := rawCheck["checkOnlyChanges"]; !exists {
				lintReq.CheckOnlyChanges = true
			}
			if _, exists := rawCheck["vendorMode"]; !exists {
				lintReq.VendorMode = true
			}
		}
	}

	// 验证项目路径
	if !filepath.IsAbs(lintReq.ProjectPath) {
		return &protocol.CallToolResult{
			Content: []protocol.Content{
				&protocol.TextContent{
					Type: "text",
					Text: "项目路径必须是绝对路径",
				},
			},
		}, nil
	}

	// 检查路径是否存在
	if _, err := os.Stat(lintReq.ProjectPath); err != nil {
		return &protocol.CallToolResult{
			Content: []protocol.Content{
				&protocol.TextContent{
					Type: "text",
					Text: fmt.Sprintf("项目路径不存在: %s", lintReq.ProjectPath),
				},
			},
		}, nil
	}

	// 如果 checkOnlyChanges=true，忽略项目范围，直接检查 git 最新变更的所有 Go 文件
	if lintReq.CheckOnlyChanges {
		log.Printf("checkOnlyChanges=true，通过 git 获取最新变更的 Go 文件进行检查")

		// 获取最新变更的 Go 文件
		changedFiles, err := getChangedGoFiles(lintReq.ProjectPath, "HEAD~1")
		if err != nil {
			return &protocol.CallToolResult{
				Content: []protocol.Content{
					&protocol.TextContent{
						Type: "text",
						Text: fmt.Sprintf("获取最新变更文件失败: %v", err),
					},
				},
			}, nil
		}

		log.Printf("检查项目 %s 中最新变更的 %d 个 Go 文件", lintReq.ProjectPath, len(changedFiles))

		// 执行检查，使用变更文件（不使用 --new-from-rev 参数）
		result, err := runGolangciLint(lintReq.ProjectPath, changedFiles, "project", false, lintReq.VendorMode)
		if err != nil {
			return nil, err
		}

		// 返回结果
		resultJSON, _ := json.Marshal(result)
		return &protocol.CallToolResult{
			Content: []protocol.Content{
				&protocol.TextContent{
					Type: "text",
					Text: string(resultJSON),
				},
			},
		}, nil
	}

	// checkOnlyChanges=false 时，执行检查（检查指定目录下所有Go文件）
	result, err := runGolangciLint(lintReq.ProjectPath, []string{"."}, "project", lintReq.CheckOnlyChanges, lintReq.VendorMode)
	if err != nil {
		return nil, err
	}

	// 返回结果
	resultJSON, _ := json.Marshal(result)
	return &protocol.CallToolResult{
		Content: []protocol.Content{
			&protocol.TextContent{
				Type: "text",
				Text: string(resultJSON),
			},
		},
	}, nil
}

func main() {
	flag.Parse()

	log.Printf("启动代码检查MCP服务...")

	// 创建 StdioServer 传输服务器
	transportServer := transport.NewStdioServerTransport()

	// 初始化 MCP 服务器
	mcpServer, err := server.NewServer(transportServer,
		server.WithCapabilities(protocol.ServerCapabilities{
			Tools: &protocol.ToolsCapability{
				ListChanged: true,
			},
		}),
		server.WithServerInfo(protocol.Implementation{
			Name:    "lint-mcp",
			Version: "1.0.0",
		}),
		server.WithInstructions("这是一个智能代码检查工具，提供三种检测级别：包级（精确检测文件所在包）、模块级（检测整个Go模块）、项目级（检测指定目录）。支持多项目使用。"),
	)
	if err != nil {
		log.Fatalf("创建 MCP 服务器失败: %v", err)
	}

	// 注册包级代码检查工具
	packageTool, err := protocol.NewTool(
		"code_lint_package",
		"检测文件所在的包。避免跨文件引用误报，提供最精确的检查结果。适用于检测特定文件的代码问题。",
		PackageLintRequest{},
	)
	if err != nil {
		log.Fatalf("创建包级检查工具失败: %v", err)
	}

	// 注册模块级代码检查工具
	moduleTool, err := protocol.NewTool(
		"code_lint_module",
		"检测整个Go模块（go.mod范围内的所有代码）。提供模块级别的全面代码检查。",
		ModuleLintRequest{},
	)
	if err != nil {
		log.Fatalf("创建模块级检查工具失败: %v", err)
	}

	// 注册项目级代码检查工具
	projectTool, err := protocol.NewTool(
		"code_lint_project",
		"检测指定目录下的所有Go文件。适用于非标准Go项目结构或部分代码检查。",
		ProjectLintRequest{},
	)
	if err != nil {
		log.Fatalf("创建项目级检查工具失败: %v", err)
	}

	// 注册工具处理器
	mcpServer.RegisterTool(packageTool, handlePackageLintRequest)
	mcpServer.RegisterTool(moduleTool, handleModuleLintRequest)
	mcpServer.RegisterTool(projectTool, handleProjectLintRequest)

	log.Printf("工具注册成功: %s, %s, %s", packageTool.Name, moduleTool.Name, projectTool.Name)

	// 启动服务器
	if err = mcpServer.Run(); err != nil {
		log.Fatalf("服务器运行失败: %v", err)
	}
}
